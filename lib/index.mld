{0 mra_bi_assembler }

Welcome to the MRA bi-assembler project.
The {{:https://github.com/katrinafyi/mra-bi-assembler} code repository} is publicly available.

For the main library documentation, see {!module:Lang}.

The goal of this project is to provide a framework for automatically-generating
instruction assemblers and disassemblers, given a machine-readable description
of an architecture's assembly syntax.
The generated assemblers are intended to be invertible, hence the name {i bi-assembler}.

The produced bi-assembler will be able to convert to and from instruction bytes and
an assembly mnemonic.
For example, for aarch64, one such conversion is:
{v
add x1, x2, x3, lsl #4  <->  0x8b031041
v}

We note that this project {i does not} do object assembly
(i.e., each instruction is (dis)assembled in isolation and it does not support symbolic addresses or labels).

The {!module:Lang} library provides an architecture-agnostic domain-specific language, {!Lang.Common.parseable},
for defining assembly parsers and instruction decoders.
These are unified in this framework. For example, a decoder is just a parser with byte strings as input.
Abiding by some minor constraints, these parses can be made to be reversible, enabling their use in a bi-directional
conversion (see {!Lang.Analysis.unparse}).

It is anticipated that {i frontends} will construct the abstractions in {!module:Lang}
from some architecture-specific data files.
In order to be functional for assembly and disassembly, a frontend should produce approximately:
{ul
{- an instruction decoder: parsing instruction bytes (e.g., as a string of binary characters) to an encoding name.}
{- for each encoding name:
  {ul
  {- an assembly parser: parsing assembly text and extracting its fields (e.g., [mov x1, x2] parses to [{Xd=x1; Xn=x2}]).}
  {- a bitfield extractor: parsing a binary string and extracting its fields (e.g., [0011] parses to [Xd=11]).}
  }
}
{- for each kind of field used in the syntax:
  {ul
  {- a field formatter: converting a binary encoding to its textual string (e.g., [11] parses to [Xd]).}
}
}
}
Then, the assembly parser is constructed by joining all the encoding parsers with the {!module-Lang.Common.Or} operator.

{1 Related work}

This project as a whole is essentially the same as {{:https://alastairreid.github.io/bidirectional-assemblers/} Alastair Reid's work}
on {i Bidirectional ARM Assembly Syntax Specifications}. We have similar motivations and even use the same source for
the instruction information (the ARM machine-readable architecture).
We differ slightly in the implementation; we have a goal of being more generic and independent of the ARM specification language.
This is most obvious in how we implement conversion of assembly symbols (such as [x1], [#100]) to/from their bit encodings.
To implement these translations, Alastair Reid writes snippets of ASL code for one direction (byte to string)
and some manually-specified regular expressions for the inverse (string to byte).
In our project, this is handled by the {!Bidir} module.
By defining a bidirectional imperative language 
and using this to extract parse patterns,
we are able to implement a more general and automatic translation.

The project can also be compared to {{:https://fossies.org/linux/ghidra/GhidraDocs/languages/html/sleigh.html} Ghidra's Sleigh}
(itself a continuation of {{:https://dl.acm.org/doi/10.1145/256167.256225}SLED}).
This is a comprehensive and powerful language for defining instruction sets and assembly code.
We approach the problem more abstractly, designing the {!Lang} and {!Bidir} modules to solve abstract problems
instead of specialising to assembly code.
This is approach is mostly beneficial, but requires ISA frontends to do more work when generating the DSLs
for their language.

The languages definable in the {!Lang.Common.parseable} DSL are a restriction of the {{: https://en.wikipedia.org/wiki/Star-free_language} star-free languages}.
The star-free languages are regular expressions without the Kleene star for unbounded repetition.
We restrict this even further by omitting the complement operation.
One consequence of this is that all our definable languages have a finite maximum size
(both that the maximum length of an accepted word is finite, and that the number of distinct accepted words is finite).

This work is very much within the field of 
{{:https://en.wikipedia.org/wiki/Bidirectional_transformation} bidirectional transformations},
programs which can be run "forwards" and "backwards".
Bidirectional transformations are implemented by, for example, the {{:https://www.seas.upenn.edu/~harmony/} Boomerang language} ({{:https://en.wikipedia.org/wiki/Boomerang_(programming_language)} Wikipedia})
using functional lenses to define the transformation.
Our parsing/unparsing approach is a more ad-hoc implementation of a transformation.
Our bidirectional DSL is very similar to Boomerang but more minimal and likely less flexible.
We develop this project separately because Boomerang is somewhat dormant with outdated dependencies,
and we do not need its full power since our language is relatively simple.

The {{: https://github.com/toodom02/ocamlregextkit} [ocamlregexkit]} package defines analyses and transformations for regular expressions.
In particular, their [Tree.re] type is very similar to our {!Lang.Common.parseable}.
They also define conversions to and from NFA/DFA.
We exploit our more restricted language to implement features such as {!Lang.Analysis.unparse}, which are
crucial to our application.




{1 Library mra_bi_assembler.lang}

The entry point of this library is the module: {!module:Lang}.

{1 Library mra_bi_assembler.bidir}

The entry point of this library is the module: {!module:Bidir}.


{1 Library mra_bi_assembler.arm}

The entry point of this library is the module: {!module:Arm}.

